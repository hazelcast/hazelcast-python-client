
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AtomicReference &#8212; Hazelcast Python Client 4.0.0b1 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="CountDownLatch" href="hazelcast.proxy.cp.count_down_latch.html" />
    <link rel="prev" title="AtomicLong" href="hazelcast.proxy.cp.atomic_long.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="hazelcast.proxy.cp.count_down_latch.html" title="CountDownLatch"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="hazelcast.proxy.cp.atomic_long.html" title="AtomicLong"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Hazelcast Python Client 4.0.0b1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="hazelcast.html" >Hazelcast Python Client</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="hazelcast.proxy.html" >Hazelcast Proxies</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="hazelcast.proxy.cp.html" accesskey="U">CP Proxies</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">AtomicReference</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-hazelcast.proxy.cp.atomic_reference">
<span id="atomicreference"></span><h1>AtomicReference<a class="headerlink" href="#module-hazelcast.proxy.cp.atomic_reference" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="hazelcast.proxy.cp.atomic_reference.AtomicReference">
<em class="property">class </em><code class="sig-name descname">AtomicReference</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span></em>, <em class="sig-param"><span class="n">group_id</span></em>, <em class="sig-param"><span class="n">service_name</span></em>, <em class="sig-param"><span class="n">proxy_name</span></em>, <em class="sig-param"><span class="n">object_name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.cp.atomic_reference.AtomicReference" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">hazelcast.proxy.cp.BaseCPProxy</span></code></p>
<p>A distributed, highly available object reference with atomic operations.</p>
<p>AtomicReference offers linearizability during crash failures and network
partitions. It is CP with respect to the CAP principle. If a network
partition occurs, it remains available on at most one side of the partition.</p>
<p>The following are some considerations you need to know when you use AtomicReference:</p>
<ul class="simple">
<li><p>AtomicReference works based on the byte-content and not on the object-reference.
If you use the <code class="docutils literal notranslate"><span class="pre">compare_and_set()</span></code> method, do not change to the original
value because its serialized content will then be different.</p></li>
<li><p>All methods returning an object return a private copy. You can modify the private
copy, but the rest of the world is shielded from your changes. If you want these
changes to be visible to the rest of the world, you need to write the change back
to the AtomicReference; but be careful about introducing a data-race.</p></li>
<li><p>The in-memory format of an AtomicReference is <code class="docutils literal notranslate"><span class="pre">binary</span></code>. The receiving side
does not need to have the class definition available unless it needs to be
deserialized on the other side., e.g., because a method like <cite>alter()</cite> is executed.
This deserialization is done for every call that needs to have the object instead
of the binary content, so be careful with expensive object graphs that need to be
deserialized.</p></li>
<li><p>If you have an object with many fields or an object graph and you only need to
calculate some information or need a subset of fields, you can use the <cite>apply()</cite>
method. With the <cite>apply()</cite> method, the whole object does not need to be sent over
the line; only the information that is relevant is sent.</p></li>
</ul>
<p>IAtomicReference does not offer exactly-once / effectively-once
execution semantics. It goes with at-least-once execution semantics
by default and can cause an API call to be committed multiple times
in case of CP member failures. It can be tuned to offer at-most-once
execution semantics. Please see <cite>fail-on-indeterminate-operation-state</cite>
server-side setting.</p>
<dl class="py method">
<dt id="hazelcast.proxy.cp.atomic_reference.AtomicReference.compare_and_set">
<code class="sig-name descname">compare_and_set</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expect</span></em>, <em class="sig-param"><span class="n">update</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.cp.atomic_reference.AtomicReference.compare_and_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomically sets the value to the given updated value
only if the current value is equal to the expected value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expect</strong> – The expected value.</p></li>
<li><p><strong>update</strong> – The new value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if successful, or <code class="docutils literal notranslate"><span class="pre">False</span></code>
if the actual value was not equal to the expected value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[bool]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.cp.atomic_reference.AtomicReference.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.cp.atomic_reference.AtomicReference.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the current value.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The current value.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[any]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.cp.atomic_reference.AtomicReference.set">
<code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.cp.atomic_reference.AtomicReference.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomically sets the given value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>new_value</strong> – The new value.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[None]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.cp.atomic_reference.AtomicReference.get_and_set">
<code class="sig-name descname">get_and_set</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.cp.atomic_reference.AtomicReference.get_and_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the old value and sets the new value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>new_value</strong> – The new value.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The old value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[any]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.cp.atomic_reference.AtomicReference.is_none">
<code class="sig-name descname">is_none</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.cp.atomic_reference.AtomicReference.is_none" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the stored reference is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">True`</span> <span class="pre">if</span> <span class="pre">the</span> <span class="pre">stored</span> <span class="pre">reference</span> <span class="pre">is</span> <span class="pre">``None</span></code>,</dt><dd><p><code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[bool]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.cp.atomic_reference.AtomicReference.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.cp.atomic_reference.AtomicReference.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the current stored reference, so it becomes <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[None]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.cp.atomic_reference.AtomicReference.contains">
<code class="sig-name descname">contains</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.cp.atomic_reference.AtomicReference.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the reference contains the value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> – The value to check (is allowed to be <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the value is found, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[bool]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.cp.atomic_reference.AtomicReference.alter">
<code class="sig-name descname">alter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.cp.atomic_reference.AtomicReference.alter" title="Permalink to this definition">¶</a></dt>
<dd><p>Alters the currently stored reference by applying a function on it.</p>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">function</span></code> must be an instance of <code class="docutils literal notranslate"><span class="pre">IdentifiedDataSerializable</span></code> or
<code class="docutils literal notranslate"><span class="pre">Portable</span></code> that has a counterpart that implements the
<cite>com.hazelcast.core.IFunction</cite> interface registered on the server-side with
the actual implementation of the function to be applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>function</strong> (<a class="reference internal" href="hazelcast.serialization.html#hazelcast.serialization.api.Portable" title="hazelcast.serialization.api.Portable"><em>hazelcast.serialization.api.Portable</em></a><em> or </em><a class="reference internal" href="hazelcast.serialization.html#hazelcast.serialization.api.IdentifiedDataSerializable" title="hazelcast.serialization.api.IdentifiedDataSerializable"><em>hazelcast.serialization.api.IdentifiedDataSerializable</em></a>) – The function that alters the currently stored reference.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[None]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.cp.atomic_reference.AtomicReference.alter_and_get">
<code class="sig-name descname">alter_and_get</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.cp.atomic_reference.AtomicReference.alter_and_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Alters the currently stored reference by applying a function on it and
gets the result.</p>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">function</span></code> must be an instance of <code class="docutils literal notranslate"><span class="pre">IdentifiedDataSerializable</span></code> or
<code class="docutils literal notranslate"><span class="pre">Portable</span></code> that has a counterpart that implements the
<cite>com.hazelcast.core.IFunction</cite> interface registered on the server-side with
the actual implementation of the function to be applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>function</strong> (<a class="reference internal" href="hazelcast.serialization.html#hazelcast.serialization.api.Portable" title="hazelcast.serialization.api.Portable"><em>hazelcast.serialization.api.Portable</em></a><em> or </em><a class="reference internal" href="hazelcast.serialization.html#hazelcast.serialization.api.IdentifiedDataSerializable" title="hazelcast.serialization.api.IdentifiedDataSerializable"><em>hazelcast.serialization.api.IdentifiedDataSerializable</em></a>) – The function that alters the currently stored reference.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The new value, the result of the applied function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[any]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.cp.atomic_reference.AtomicReference.get_and_alter">
<code class="sig-name descname">get_and_alter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.cp.atomic_reference.AtomicReference.get_and_alter" title="Permalink to this definition">¶</a></dt>
<dd><p>Alters the currently stored reference by applying a function on it on
and gets the old value.</p>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">function</span></code> must be an instance of <code class="docutils literal notranslate"><span class="pre">IdentifiedDataSerializable</span></code> or
<code class="docutils literal notranslate"><span class="pre">Portable</span></code> that has a counterpart that implements the
<cite>com.hazelcast.core.IFunction</cite> interface registered on the server-side with
the actual implementation of the function to be applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>function</strong> (<a class="reference internal" href="hazelcast.serialization.html#hazelcast.serialization.api.Portable" title="hazelcast.serialization.api.Portable"><em>hazelcast.serialization.api.Portable</em></a><em> or </em><a class="reference internal" href="hazelcast.serialization.html#hazelcast.serialization.api.IdentifiedDataSerializable" title="hazelcast.serialization.api.IdentifiedDataSerializable"><em>hazelcast.serialization.api.IdentifiedDataSerializable</em></a>) – The function that alters the currently stored reference.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The old value, the value before the function is applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[any]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.cp.atomic_reference.AtomicReference.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.cp.atomic_reference.AtomicReference.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a function on the value, the actual stored value will not
change.</p>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">function</span></code> must be an instance of <code class="docutils literal notranslate"><span class="pre">IdentifiedDataSerializable</span></code> or
<code class="docutils literal notranslate"><span class="pre">Portable</span></code> that has a counterpart that implements the
<cite>com.hazelcast.core.IFunction</cite> interface registered on the server-side with
the actual implementation of the function to be applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>function</strong> (<a class="reference internal" href="hazelcast.serialization.html#hazelcast.serialization.api.Portable" title="hazelcast.serialization.api.Portable"><em>hazelcast.serialization.api.Portable</em></a><em> or </em><a class="reference internal" href="hazelcast.serialization.html#hazelcast.serialization.api.IdentifiedDataSerializable" title="hazelcast.serialization.api.IdentifiedDataSerializable"><em>hazelcast.serialization.api.IdentifiedDataSerializable</em></a>) – The function applied on the currently stored reference.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The result of the function application.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[any]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="hazelcast.proxy.cp.atomic_long.html"
                        title="previous chapter">AtomicLong</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="hazelcast.proxy.cp.count_down_latch.html"
                        title="next chapter">CountDownLatch</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/hazelcast.proxy.cp.atomic_reference.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="hazelcast.proxy.cp.count_down_latch.html" title="CountDownLatch"
             >next</a> |</li>
        <li class="right" >
          <a href="hazelcast.proxy.cp.atomic_long.html" title="AtomicLong"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Hazelcast Python Client 4.0.0b1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="hazelcast.html" >Hazelcast Python Client</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="hazelcast.proxy.html" >Hazelcast Proxies</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="hazelcast.proxy.cp.html" >CP Proxies</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">AtomicReference</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Hazelcast Inc..
    </div>
  </body>
</html>