
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Predicate &#8212; Hazelcast Python Client 4.0.0b1 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Hazelcast Proxies" href="hazelcast.proxy.html" />
    <link rel="prev" title="Partition" href="hazelcast.partition.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="hazelcast.proxy.html" title="Hazelcast Proxies"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="hazelcast.partition.html" title="Partition"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Hazelcast Python Client 4.0.0b1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="hazelcast.html" accesskey="U">Hazelcast Python Client</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Predicate</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-hazelcast.predicate">
<span id="predicate"></span><h1>Predicate<a class="headerlink" href="#module-hazelcast.predicate" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="hazelcast.predicate.Predicate">
<em class="property">class </em><code class="sig-name descname">Predicate</code><a class="headerlink" href="#hazelcast.predicate.Predicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a map entry predicate. Implementations of this class are
basic building blocks for performing queries on map entries.</p>
<p><strong>Special Attributes</strong></p>
<p>The predicates that accept an attribute name support two special
attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__key</span></code> - instructs the predicate to act on the key associated
with an item.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">this</span></code> - instructs the predicate to act on the value associated
with an item.</p></li>
</ul>
<p><strong>Attribute Paths</strong></p>
<p>Dot notation may be used for attribute name to instruct the predicate to
act on the attribute located at deeper level of an item. Given
<code class="docutils literal notranslate"><span class="pre">&quot;full_name.first_name&quot;</span></code> path the predicate will act on <code class="docutils literal notranslate"><span class="pre">first_name</span></code>
attribute of the value fetched by <code class="docutils literal notranslate"><span class="pre">full_name</span></code> attribute from the item
itself. If any of the attributes along the path can’t be resolved,
<code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> will be thrown. Reading of any attribute from
<code class="docutils literal notranslate"><span class="pre">None</span></code> will produce <code class="docutils literal notranslate"><span class="pre">None</span></code> value.</p>
<p>Square brackets notation may be used to instruct the predicate to act on
the list element at the specified index. Given <code class="docutils literal notranslate"><span class="pre">&quot;names[0]&quot;</span></code> path the
predicate will act on the first item of the list fetched by <code class="docutils literal notranslate"><span class="pre">names</span></code>
attribute from the item. The index must be non-negative, otherwise
<code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> will be thrown. Reading from the index pointing
beyond the end of the list will produce <code class="docutils literal notranslate"><span class="pre">None</span></code> value.</p>
<p>Special <code class="docutils literal notranslate"><span class="pre">any</span></code> keyword may be used to act on every list element. Given
<code class="docutils literal notranslate"><span class="pre">&quot;names[any].full_name.first_name&quot;</span></code> path the predicate will act on
<code class="docutils literal notranslate"><span class="pre">first_name</span></code> attribute of the value fetched by <code class="docutils literal notranslate"><span class="pre">full_name</span></code> attribute
from every list element stored in the item itself under <code class="docutils literal notranslate"><span class="pre">names</span></code>
attribute.</p>
<p><strong>Handling of None</strong></p>
<p>The predicates that accept <code class="docutils literal notranslate"><span class="pre">None</span></code> as a value to compare with or a pattern
to match against if and only if that is explicitly stated in the method
documentation. In this case, the usual equality logic applies: if <code class="docutils literal notranslate"><span class="pre">None</span></code>
is provided, the predicate passes an item if and only if the value stored
under the item attribute in question is also <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Special care must be taken while comparing with <code class="docutils literal notranslate"><span class="pre">None</span></code> values <em>stored</em>
inside items being filtered through the predicates created by the following
methods: <a class="reference internal" href="#hazelcast.predicate.greater" title="hazelcast.predicate.greater"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater()</span></code></a>, <a class="reference internal" href="#hazelcast.predicate.greater_or_equal" title="hazelcast.predicate.greater_or_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater_or_equal()</span></code></a>, <a class="reference internal" href="#hazelcast.predicate.less" title="hazelcast.predicate.less"><code class="xref py py-func docutils literal notranslate"><span class="pre">less()</span></code></a>,
<a class="reference internal" href="#hazelcast.predicate.less_or_equal" title="hazelcast.predicate.less_or_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">less_or_equal()</span></code></a>, <a class="reference internal" href="#hazelcast.predicate.between" title="hazelcast.predicate.between"><code class="xref py py-func docutils literal notranslate"><span class="pre">between()</span></code></a>. They always evaluate to <code class="docutils literal notranslate"><span class="pre">False</span></code>
and therefore never pass such items.</p>
<p><strong>Implicit Type Conversion</strong></p>
<p>If the type of the stored value doesn’t match the type of the value
provided to the predicate, implicit type conversion is performed before
predicate evaluation. The provided value is converted to match the type of
the stored attribute value. If no conversion matching the type exists,
<code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> is thrown.</p>
</dd></dl>

<dl class="py class">
<dt id="hazelcast.predicate.PagingPredicate">
<em class="property">class </em><code class="sig-name descname">PagingPredicate</code><a class="headerlink" href="#hazelcast.predicate.PagingPredicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hazelcast.predicate.Predicate</span></code></a></p>
<p>This class is a special Predicate which helps to get a page-by-page
result of a query.</p>
<p>It can be constructed with a page-size, an inner predicate for filtering,
and a comparator for sorting. This class is not thread-safe and stateless.
To be able to reuse for another query, one should call <a class="reference internal" href="#hazelcast.predicate.PagingPredicate.reset" title="hazelcast.predicate.PagingPredicate.reset"><code class="xref py py-func docutils literal notranslate"><span class="pre">reset()</span></code></a>.</p>
<dl class="py method">
<dt id="hazelcast.predicate.PagingPredicate.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.PagingPredicate.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the predicate for reuse.</p>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.predicate.PagingPredicate.next_page">
<code class="sig-name descname">next_page</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.PagingPredicate.next_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets page index to next page.</p>
<p>If new index is out of range, the query results that this
paging predicate will retrieve will be an empty list.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Updated page index</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.predicate.PagingPredicate.previous_page">
<code class="sig-name descname">previous_page</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.PagingPredicate.previous_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets page index to previous page.</p>
<p>If current page index is 0, this method does nothing.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Updated page index.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.predicate.PagingPredicate.page">
<em class="property">property </em><code class="sig-name descname">page</code><a class="headerlink" href="#hazelcast.predicate.PagingPredicate.page" title="Permalink to this definition">¶</a></dt>
<dd><p>The current page index.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter</dt>
<dd class="field-odd"><p>Returns the current page index.</p>
</dd>
<dt class="field-even">Setter</dt>
<dd class="field-even"><p>Sets the current page index. If the page is out of range, the
query results that this paging predicate will retrieve will be an
empty list. New page index must be greater than or equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.predicate.PagingPredicate.page_size">
<em class="property">property </em><code class="sig-name descname">page_size</code><a class="headerlink" href="#hazelcast.predicate.PagingPredicate.page_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The page size.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter</dt>
<dd class="field-odd"><p>Returns the page size.</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.sql">
<code class="sig-name descname">sql</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expression</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.sql" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass items that match the given SQL
<code class="docutils literal notranslate"><span class="pre">where</span></code> expression.</p>
<p>The following operators are supported: <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>
<code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">BETWEEN</span></code>, <code class="docutils literal notranslate"><span class="pre">IN</span></code>, <code class="docutils literal notranslate"><span class="pre">LIKE</span></code>, <code class="docutils literal notranslate"><span class="pre">ILIKE</span></code>, <code class="docutils literal notranslate"><span class="pre">REGEX</span></code>
<code class="docutils literal notranslate"><span class="pre">AND</span></code>, <code class="docutils literal notranslate"><span class="pre">OR</span></code>, <code class="docutils literal notranslate"><span class="pre">NOT</span></code>.</p>
<p>The operators are case-insensitive, but attribute names are case sensitive.</p>
<p>Example: <code class="docutils literal notranslate"><span class="pre">active</span> <span class="pre">AND</span> <span class="pre">(age</span> <span class="pre">&gt;</span> <span class="pre">20</span> <span class="pre">OR</span> <span class="pre">salary</span> <span class="pre">&lt;</span> <span class="pre">60000)</span></code></p>
<p>Differences to standard SQL:</p>
<ul class="simple">
<li><p>We don’t use ternary boolean logic. <code class="docutils literal notranslate"><span class="pre">field=10</span></code> evaluates to <code class="docutils literal notranslate"><span class="pre">false</span></code>,
if <code class="docutils literal notranslate"><span class="pre">field</span></code> is <code class="docutils literal notranslate"><span class="pre">null</span></code>, in standard SQL it evaluates to <code class="docutils literal notranslate"><span class="pre">UNKNOWN</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IS</span> <span class="pre">[NOT]</span> <span class="pre">NULL</span></code> is not supported, use <code class="docutils literal notranslate"><span class="pre">=NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">&lt;&gt;NULL</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IS</span> <span class="pre">[NOT]</span> <span class="pre">DISTINCT</span> <span class="pre">FROM</span></code> is not supported, but <code class="docutils literal notranslate"><span class="pre">=</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> behave
like it.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expression</strong> (<em>str</em>) – The <code class="docutils literal notranslate"><span class="pre">where</span></code> expression.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>sql</strong> predicate instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.equal">
<code class="sig-name descname">equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attribute</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass items if the given <code class="docutils literal notranslate"><span class="pre">value</span></code> and the
value stored under the given item <code class="docutils literal notranslate"><span class="pre">attribute</span></code> are equal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> (<em>str</em>) – The attribute to fetch the value for comparison from.</p></li>
<li><p><strong>value</strong> – The value to compare the attribute value against. Can be
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>equal</strong> predicate instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.not_equal">
<code class="sig-name descname">not_equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attribute</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.not_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass items if the given <code class="docutils literal notranslate"><span class="pre">value</span></code> and the
value stored under the given item <code class="docutils literal notranslate"><span class="pre">attribute</span></code> are not equal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> (<em>str</em>) – The attribute to fetch the value for comparison from.</p></li>
<li><p><strong>value</strong> – The value to compare the attribute value against. Can be
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>not equal</strong> predicate instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.like">
<code class="sig-name descname">like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attribute</span></em>, <em class="sig-param"><span class="n">pattern</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.like" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass items if the given <code class="docutils literal notranslate"><span class="pre">pattern</span></code>
matches the value stored under the given item <code class="docutils literal notranslate"><span class="pre">attribute</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> (<em>str</em>) – The attribute to fetch the value for matching from.</p></li>
<li><p><strong>pattern</strong> (<em>str</em>) – The pattern to match the attribute value against.
The <code class="docutils literal notranslate"><span class="pre">%</span></code> (percentage sign) is a placeholder for multiple
characters, the <code class="docutils literal notranslate"><span class="pre">_</span></code> (underscore) is a placeholder for a single
character. If you need to match the percentage sign or the
underscore character itself, escape it with the backslash, for
example <code class="docutils literal notranslate"><span class="pre">&quot;\%&quot;</span></code> string will match the percentage sign. Can be
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>like</strong> predicate instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hazelcast.predicate.ilike" title="hazelcast.predicate.ilike"><code class="xref py py-func docutils literal notranslate"><span class="pre">ilike()</span></code></a> and <a class="reference internal" href="#hazelcast.predicate.regex" title="hazelcast.predicate.regex"><code class="xref py py-func docutils literal notranslate"><span class="pre">regex()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.ilike">
<code class="sig-name descname">ilike</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attribute</span></em>, <em class="sig-param"><span class="n">pattern</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.ilike" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass items if the given <code class="docutils literal notranslate"><span class="pre">pattern</span></code>
matches  the value stored under the given item <code class="docutils literal notranslate"><span class="pre">attribute</span></code> in a
case-insensitive manner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> (<em>str</em>) – The attribute to fetch the value for matching from.</p></li>
<li><p><strong>pattern</strong> (<em>str</em>) – The pattern to match the attribute value against.
The <code class="docutils literal notranslate"><span class="pre">%</span></code> (percentage sign) is a placeholder for multiple
characters, the <code class="docutils literal notranslate"><span class="pre">_</span></code> (underscore) is a placeholder for a single
character. If you need to match the percentage sign or the
underscore character itself, escape it with the backslash, for
example <code class="docutils literal notranslate"><span class="pre">&quot;\%&quot;</span></code> string will match the percentage sign. Can be
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>case-insensitive like</strong> predicate instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hazelcast.predicate.like" title="hazelcast.predicate.like"><code class="xref py py-func docutils literal notranslate"><span class="pre">like()</span></code></a> and <a class="reference internal" href="#hazelcast.predicate.regex" title="hazelcast.predicate.regex"><code class="xref py py-func docutils literal notranslate"><span class="pre">regex()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.regex">
<code class="sig-name descname">regex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attribute</span></em>, <em class="sig-param"><span class="n">pattern</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.regex" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass items if the given <code class="docutils literal notranslate"><span class="pre">pattern</span></code>
matches the value stored under the given item <code class="docutils literal notranslate"><span class="pre">attribute</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> (<em>str</em>) – The attribute to fetch the value for matching from.</p></li>
<li><p><strong>pattern</strong> (<em>str</em>) – The pattern to match the attribute value against. The
pattern interpreted exactly the same as described in
<a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html</a>.
Can be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>regex</strong> predicate instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hazelcast.predicate.ilike" title="hazelcast.predicate.ilike"><code class="xref py py-func docutils literal notranslate"><span class="pre">ilike()</span></code></a> and <a class="reference internal" href="#hazelcast.predicate.like" title="hazelcast.predicate.like"><code class="xref py py-func docutils literal notranslate"><span class="pre">like()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.and_">
<code class="sig-name descname">and_</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">predicates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.and_" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will perform the logical <code class="docutils literal notranslate"><span class="pre">and</span></code> operation on
the given predicates.</p>
<p>If no predicate is provided as argument, the created predicate will always
evaluate to <code class="docutils literal notranslate"><span class="pre">true</span></code> and will pass any item.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*predicates</strong> (<a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate"><em>Predicate</em></a>) – The child predicates to form the resulting
<code class="docutils literal notranslate"><span class="pre">and</span></code> predicate from.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>and</strong> predicate instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.or_">
<code class="sig-name descname">or_</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">predicates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.or_" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will perform the logical <code class="docutils literal notranslate"><span class="pre">or</span></code> operation on
the given predicates.</p>
<p>If no predicate is provided as argument, the created predicate will always
evaluate to <code class="docutils literal notranslate"><span class="pre">false</span></code> and will never pass any items.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*predicates</strong> (<a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate"><em>Predicate</em></a>) – The child predicates to form the resulting
<code class="docutils literal notranslate"><span class="pre">or</span></code> predicate from.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>or</strong> predicate instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.not_">
<code class="sig-name descname">not_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predicate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.not_" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will negate the result of the given
<code class="docutils literal notranslate"><span class="pre">predicate</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>predicate</strong> (<a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate"><em>Predicate</em></a>) – The predicate to negate the value of.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>not</strong> predicate instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.between">
<code class="sig-name descname">between</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attribute</span></em>, <em class="sig-param"><span class="n">from_</span></em>, <em class="sig-param"><span class="n">to</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.between" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass items if the value stored under the
given item <code class="docutils literal notranslate"><span class="pre">attribute</span></code> is contained inside the given range.</p>
<p>The range begins at the given <code class="docutils literal notranslate"><span class="pre">from_</span></code> bound and ends at the given <code class="docutils literal notranslate"><span class="pre">to</span></code>
bound. The bounds are inclusive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> (<em>str</em>) – The attribute to fetch the value to check from.</p></li>
<li><p><strong>from</strong> – The inclusive lower bound of the range to check.</p></li>
<li><p><strong>to</strong> – The inclusive upper bound of the range to check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>between</strong> predicate.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.in_">
<code class="sig-name descname">in_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attribute</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">values</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.in_" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass items if the value stored under the
given item <code class="docutils literal notranslate"><span class="pre">attribute</span></code> is a member of the given <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> (<em>str</em>) – The attribute to fetch the value to test from.</p></li>
<li><p><strong>*values</strong> – The values set to test the membership in. Individual values
can be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>in</strong> predicate.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.instance_of">
<code class="sig-name descname">instance_of</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">class_name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.instance_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass entries for which the value class is
an instance of the given <code class="docutils literal notranslate"><span class="pre">class_name</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>class_name</strong> (<em>str</em>) – The name of class the created predicate will check
for.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>instance of</strong> predicate.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.false">
<code class="sig-name descname">false</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.false" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will filter out all items.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The created <strong>false</strong> predicate.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.true">
<code class="sig-name descname">true</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.true" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass all items.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The created <strong>true</strong> predicate.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.paging">
<code class="sig-name descname">paging</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predicate</span></em>, <em class="sig-param"><span class="n">page_size</span></em>, <em class="sig-param"><span class="n">comparator</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.paging" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a paging predicate with an inner predicate, page size and
comparator. Results will be filtered via inner predicate and will be
ordered via comparator if provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>predicate</strong> (<a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate"><em>Predicate</em></a>) – The inner predicate through which results will
be filtered. Can be <code class="docutils literal notranslate"><span class="pre">None</span></code>. In that case, results will not be
filtered.</p></li>
<li><p><strong>page_size</strong> (<em>int</em>) – The page size.</p></li>
<li><p><strong>comparator</strong> (<a class="reference internal" href="hazelcast.serialization.html#hazelcast.serialization.api.Portable" title="hazelcast.serialization.api.Portable"><em>hazelcast.serialization.api.Portable</em></a><em> or </em><a class="reference internal" href="hazelcast.serialization.html#hazelcast.serialization.api.IdentifiedDataSerializable" title="hazelcast.serialization.api.IdentifiedDataSerializable"><em>hazelcast.serialization.api.IdentifiedDataSerializable</em></a>) – The comparator through which results will be ordered. The
comparision logic must be defined on the server side. Can be
<code class="docutils literal notranslate"><span class="pre">None</span></code>. In that case, the results will be returned in natural
order.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>paging</strong> predicate.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.PagingPredicate" title="hazelcast.predicate.PagingPredicate">PagingPredicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.greater">
<code class="sig-name descname">greater</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attribute</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.greater" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass items if the value stored under the
given item <code class="docutils literal notranslate"><span class="pre">attribute</span></code> is greater than the given <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> (<em>str</em>) – The left-hand side attribute to fetch the value for
comparison from.</p></li>
<li><p><strong>value</strong> – The right-hand side value to compare the attribute value
against.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>greater than</strong> predicate.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.greater_or_equal">
<code class="sig-name descname">greater_or_equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attribute</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.greater_or_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass items if the value stored under the
given item <code class="docutils literal notranslate"><span class="pre">attribute</span></code> is greater than or equal to the given <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> (<em>str</em>) – the left-hand side attribute to fetch the value for
comparison from.</p></li>
<li><p><strong>value</strong> – The right-hand side value to compare the attribute value
against.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>greater than or equal to</strong> predicate.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.less">
<code class="sig-name descname">less</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attribute</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.less" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass items if the value stored under the
given item <code class="docutils literal notranslate"><span class="pre">attribute</span></code> is less than the given <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> (<em>str</em>) – The left-hand side attribute to fetch the value for
comparison from.</p></li>
<li><p><strong>value</strong> – The right-hand side value to compare the attribute value
against.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>less than</strong> predicate.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="hazelcast.predicate.less_or_equal">
<code class="sig-name descname">less_or_equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attribute</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.predicate.less_or_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a predicate that will pass items if the value stored under the
given item <code class="docutils literal notranslate"><span class="pre">attribute</span></code> is less than or equal to the given <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> (<em>str</em>) – The left-hand side attribute to fetch the value for
comparison from.</p></li>
<li><p><strong>value</strong> – The right-hand side value to compare the attribute value
against.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The created <strong>less than or equal to</strong> predicate.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#hazelcast.predicate.Predicate" title="hazelcast.predicate.Predicate">Predicate</a></p>
</dd>
</dl>
</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="hazelcast.partition.html"
                        title="previous chapter">Partition</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="hazelcast.proxy.html"
                        title="next chapter">Hazelcast Proxies</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/hazelcast.predicate.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="hazelcast.proxy.html" title="Hazelcast Proxies"
             >next</a> |</li>
        <li class="right" >
          <a href="hazelcast.partition.html" title="Partition"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Hazelcast Python Client 4.0.0b1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="hazelcast.html" >Hazelcast Python Client</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Predicate</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Hazelcast Inc..
    </div>
  </body>
</html>