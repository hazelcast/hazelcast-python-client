
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RingBuffer &#8212; Hazelcast Python Client 4.0.0b1 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Set" href="hazelcast.proxy.set.html" />
    <link rel="prev" title="ReplicatedMap" href="hazelcast.proxy.replicated_map.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="hazelcast.proxy.set.html" title="Set"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="hazelcast.proxy.replicated_map.html" title="ReplicatedMap"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Hazelcast Python Client 4.0.0b1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="hazelcast.html" >Hazelcast Python Client</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="hazelcast.proxy.html" accesskey="U">Hazelcast Proxies</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">RingBuffer</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-hazelcast.proxy.ringbuffer">
<span id="ringbuffer"></span><h1>RingBuffer<a class="headerlink" href="#module-hazelcast.proxy.ringbuffer" title="Permalink to this headline">¶</a></h1>
<dl class="py data">
<dt id="hazelcast.proxy.ringbuffer.OVERFLOW_POLICY_OVERWRITE">
<code class="sig-name descname">OVERFLOW_POLICY_OVERWRITE</code><em class="property"> = 0</em><a class="headerlink" href="#hazelcast.proxy.ringbuffer.OVERFLOW_POLICY_OVERWRITE" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration property for DEFAULT overflow policy. When an item is tried to be added on full Ringbuffer, oldest item in
the Ringbuffer is overwritten and item is added.</p>
</dd></dl>

<dl class="py data">
<dt id="hazelcast.proxy.ringbuffer.OVERFLOW_POLICY_FAIL">
<code class="sig-name descname">OVERFLOW_POLICY_FAIL</code><em class="property"> = 1</em><a class="headerlink" href="#hazelcast.proxy.ringbuffer.OVERFLOW_POLICY_FAIL" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration property for overflow policy. When an item is tried to be added on full Ringbuffer, the call fails and
item is not added.</p>
<p>The reason that FAIL exist is to give the opportunity to obey the ttl. If blocking behavior is required, this can be
implemented using retrying in combination with an exponential backoff.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sleepMS</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="n">true</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">ringbuffer</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">break</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">sleep</span><span class="p">(</span><span class="n">sleepMS</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">sleepMS</span> <span class="o">*=</span> <span class="mi">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py data">
<dt id="hazelcast.proxy.ringbuffer.MAX_BATCH_SIZE">
<code class="sig-name descname">MAX_BATCH_SIZE</code><em class="property"> = 1000</em><a class="headerlink" href="#hazelcast.proxy.ringbuffer.MAX_BATCH_SIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of items to be added to RingBuffer or read from RingBuffer at a time.</p>
</dd></dl>

<dl class="py class">
<dt id="hazelcast.proxy.ringbuffer.Ringbuffer">
<em class="property">class </em><code class="sig-name descname">Ringbuffer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">service_name</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">context</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.ringbuffer.Ringbuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="hazelcast.proxy.base.html#hazelcast.proxy.base.PartitionSpecificProxy" title="hazelcast.proxy.base.PartitionSpecificProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">hazelcast.proxy.base.PartitionSpecificProxy</span></code></a></p>
<p>A Ringbuffer is a data-structure where the content is stored in a ring like structure.</p>
<p>A Ringbuffer has a capacity so it won’t grow beyond that capacity and endanger the stability of the system.
If that capacity is exceeded, than the oldest item in the Ringbuffer is overwritten.
The Ringbuffer has 2 always incrementing sequences:</p>
<ul class="simple">
<li><p>Tail_sequence: This is the side where the youngest item is found. So the tail is the side of the Ringbuffer
where items are added to.</p></li>
<li><p>Head_sequence: This is the side where the oldest items are found. So the head is the side where items gets
discarded.</p></li>
</ul>
<p>The items in the Ringbuffer can be found by a sequence that is in between (inclusive) the head and tail sequence.</p>
<p>A Ringbuffer currently is not a distributed data-structure. So all data is stored in a single partition; comparable
to the IQueue implementation. But we’ll provide an option to partition the data in the near future. A Ringbuffer
can be used in a similar way as a queue, but one of the key differences is that a queue.take is destructive,
meaning that only 1 thread is able to take an item. A Ringbuffer.read is not destructive, so you can have multiple
threads reading the same item multiple times.</p>
<dl class="py method">
<dt id="hazelcast.proxy.ringbuffer.Ringbuffer.capacity">
<code class="sig-name descname">capacity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.ringbuffer.Ringbuffer.capacity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the capacity of this Ringbuffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The capacity of Ringbuffer.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.ringbuffer.Ringbuffer.size">
<code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.ringbuffer.Ringbuffer.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of items in the Ringbuffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The size of Ringbuffer.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.ringbuffer.Ringbuffer.tail_sequence">
<code class="sig-name descname">tail_sequence</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.ringbuffer.Ringbuffer.tail_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sequence of the tail.</p>
<p>The tail is the side of the Ringbuffer where the items are added to. The initial value of the tail is -1.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The sequence of the tail.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.ringbuffer.Ringbuffer.head_sequence">
<code class="sig-name descname">head_sequence</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.ringbuffer.Ringbuffer.head_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sequence of the head.</p>
<p>The head is the side of the Ringbuffer where the oldest items in the Ringbuffer are found.
If the Ringbuffer is empty, the head will be one more than the tail. The initial value of
the head is 0 (1 more than tail).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The sequence of the head.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.ringbuffer.Ringbuffer.remaining_capacity">
<code class="sig-name descname">remaining_capacity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.ringbuffer.Ringbuffer.remaining_capacity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the remaining capacity of the Ringbuffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The remaining capacity of Ringbuffer.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.ringbuffer.Ringbuffer.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">item</span></em>, <em class="sig-param"><span class="n">overflow_policy</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.ringbuffer.Ringbuffer.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the specified item to the tail of the Ringbuffer.</p>
<p>If there is no space in the Ringbuffer, the action is determined by overflow policy
as <code class="docutils literal notranslate"><span class="pre">OVERFLOW_POLICY_OVERWRITE</span></code> or <code class="docutils literal notranslate"><span class="pre">OVERFLOW_POLICY_FAIL</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>item</strong> – The specified item to be added.</p></li>
<li><p><strong>overflow_policy</strong> (<em>int</em>) – the OverflowPolicy to be used when there is no space.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The sequenceId of the added item, or <code class="docutils literal notranslate"><span class="pre">-1</span></code> if the add failed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.ringbuffer.Ringbuffer.add_all">
<code class="sig-name descname">add_all</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">items</span></em>, <em class="sig-param"><span class="n">overflow_policy</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.ringbuffer.Ringbuffer.add_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds all of the item in the specified collection to the tail of the Ringbuffer.</p>
<p>An add_all is likely to outperform multiple calls to add(object) due to better io utilization
and a reduced number of executed operations. The items are added in the order of the Iterator of the collection.</p>
<p>If there is no space in the Ringbuffer, the action is determined by overflow policy
as <code class="docutils literal notranslate"><span class="pre">OVERFLOW_POLICY_OVERWRITE</span></code> or <code class="docutils literal notranslate"><span class="pre">OVERFLOW_POLICY_FAIL</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>items</strong> (<em>list</em>) – The specified collection which contains the items to be added.</p></li>
<li><p><strong>overflow_policy</strong> (<em>int</em>) – The OverflowPolicy to be used when there is no space.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>The sequenceId of the last written item, or <code class="docutils literal notranslate"><span class="pre">-1</span></code></dt><dd><p>of the last write is failed.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.ringbuffer.Ringbuffer.read_one">
<code class="sig-name descname">read_one</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sequence</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.ringbuffer.Ringbuffer.read_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads one item from the Ringbuffer.</p>
<p>If the sequence is one beyond the current tail, this call blocks until an item is added.
Currently it isn’t possible to control how long this call is going to block.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sequence</strong> (<em>int</em>) – The sequence of the item to read.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The read item.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="hazelcast.proxy.ringbuffer.Ringbuffer.read_many">
<code class="sig-name descname">read_many</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start_sequence</span></em>, <em class="sig-param"><span class="n">min_count</span></em>, <em class="sig-param"><span class="n">max_count</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hazelcast.proxy.ringbuffer.Ringbuffer.read_many" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a batch of items from the Ringbuffer.</p>
<p>If the number of available items after the first read item is smaller than the max_count,
these items are returned. So it could be the number of items read is smaller than the max_count.
If there are less items available than min_count, then this call blocks. Reading a batch of items
is likely to perform better because less overhead is involved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_sequence</strong> (<em>int</em>) – The start_sequence of the first item to read.</p></li>
<li><p><strong>min_count</strong> (<em>int</em>) – The minimum number of items to read.</p></li>
<li><p><strong>max_count</strong> (<em>int</em>) – The maximum number of items to read.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The list of read items.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="hazelcast.future.html#hazelcast.future.Future" title="hazelcast.future.Future">hazelcast.future.Future</a>[list]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="hazelcast.proxy.replicated_map.html"
                        title="previous chapter">ReplicatedMap</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="hazelcast.proxy.set.html"
                        title="next chapter">Set</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/hazelcast.proxy.ringbuffer.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="hazelcast.proxy.set.html" title="Set"
             >next</a> |</li>
        <li class="right" >
          <a href="hazelcast.proxy.replicated_map.html" title="ReplicatedMap"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Hazelcast Python Client 4.0.0b1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="hazelcast.html" >Hazelcast Python Client</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="hazelcast.proxy.html" >Hazelcast Proxies</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">RingBuffer</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Hazelcast Inc..
    </div>
  </body>
</html>